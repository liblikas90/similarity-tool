<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EP Patent Tool</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    .input-group {
      margin-bottom: 20px;
    }
    .container {
      display: flex;
      gap: 30px;
    }
    .left, .right {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .box {
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background-color: #f9f9f9;
    }
    .upload-box {
      max-width: 300px;
    }
    .upload-box input[type="file"] {
      display: block;
      margin-bottom: 10px;
    }
    .loading {
      color: orange;
    }
    .error {
      color: red;
    }
    .unavailable {
      color: gray;
      font-style: italic;
    }
    h2 {
      margin-top: 0;
    }
    #uploadStatus {
      display: block;
      margin-top: 10px;
    }

    /* Make the Get XLF input fill its container */
#projectName {
  width: 100%;
  box-sizing: border-box; /* prevents padding from overflowing */
}

/* Optional: make the container itself a bit wider */
.upload-box {
  max-width: 400px; /* was 300px */
}

    /* ---- Table & equal Source/Target widths ---- */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      table-layout: fixed; /* ensures defined widths are respected */
    }
    th, td {
      padding: 6px;
      border: 1px solid #ccc;
      word-break: break-word;       /* better than deprecated word-wrap */
      white-space: normal;
      vertical-align: top;
    }
    th {
      background-color: #eee;
    }
    /* Column widths: 1) checkbox, 2) segment id, 3) source, 4) target, 5) similarity */
    #xlfPreview th:nth-child(1), #xlfPreview td:nth-child(1) { width: 40px; }
    #xlfPreview th:nth-child(2), #xlfPreview td:nth-child(2) { width: 120px; }
    #xlfPreview th:nth-child(3), #xlfPreview td:nth-child(3) { width: 24%; }  /* Source */
    #xlfPreview th:nth-child(4), #xlfPreview td:nth-child(4) { width: 24%; }  /* Target */
    #xlfPreview th:nth-child(5), #xlfPreview td:nth-child(5) { width: 90px; } /* Similarity */

    #xlfPreview {
      margin-top: 40px;
      max-width: 100%;
    }
    .ok-cell {
      background-color: #d4edda;
    }
    .check-cell {
      background-color: #ffeeba;
    }
    .highlight-cell {
      background-color: #ffe4b2;
    }
    .row-highlighted {
      background-color: #ffffcc !important;
    }
    .quoted-term {
      color: red;
      font-weight: bold;
    }
    .filter-row select {
      width: 100%;
      padding: 4px;
      font-size: 12px;
    }
    .actions-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .muted {
      color: #666;
      font-size: 12px;
    }

  </style>
</head>
<body>
  <h1>EP Patent Tool</h1>

  <div class="input-group">
    <input type="text" id="pubNum" placeholder="e.g., EP1000000" />
    <button onclick="fetchPatentInfo()">Get Title</button>
  </div>

  <div class="container">
    <div class="left">
      <div class="box">
        <h2>Titles</h2>
        <div id="result"></div>
      </div>

      <div style="display: flex; gap: 20px; align-items: flex-start; margin-top: 20px;">
        <div class="box upload-box">
          <h2>Upload .xlf File</h2>
          <form id="uploadForm">
            <input type="file" name="file" accept=".xlf" />
            <button type="submit" style="margin-top: 8px;">Upload</button>
            <span id="uploadStatus"></span>
          </form>
        </div>

        <div class="box upload-box">
          <h2>Get XLF from XTM</h2>
          <input type="text" id="projectName" placeholder="e.g. EP1234567 I01060 (EN-FR)" />
          <div class="actions-row">
            <button onclick="fetchXlfByProject()">Fetch</button>
            <button onclick="generateXtmLink()">Generate XTM Link</button>
            <span id="projectFetchStatus" class="muted"></span>
            <span id="xtmLinkStatus" class="muted"></span>
          </div>
        </div>
      </div>

      <!-- XTM Workbench (collapsible, default collapsed) ABOVE the table -->
      <details id="xtmSection" class="box" style="margin-top: 20px;">
        <summary style="cursor: pointer; user-select: none;">
          <strong>XTM Workbench</strong>
          <span id="xtmSummaryNote" class="unavailable" style="margin-left: 8px;">No link generated yet</span>
        </summary>
        <div id="xtmContainer" style="width: 100%; height: 800px; margin-top: 10px;">
          <iframe id="xtmWorkbench" src="" width="100%" height="100%" style="border: none;"></iframe>
        </div>
        <p id="xtmFallback" class="unavailable" style="display: none; margin-top: 8px;">
          ⚠️ Unable to embed the workbench.
          <a id="xtmOpenInNewTab" href="#" target="_blank" rel="noopener">Open XTM Workbench in a new tab</a>
        </p>
      </details>

      <div id="xlfPreviewContainer" style="margin-top: 20px;"></div>
      <!-- (table renders here) -->
    </div>
  </div>

  <script>
    // ---- Patent titles ----
    async function fetchPatentInfo() {
      const pub = document.getElementById("pubNum").value.trim();
      const result = document.getElementById("result");
      result.innerHTML = "<span class='loading'>⏳ Fetching titles...</span>";

      try {
        const res = await fetch(`https://ipify.app.n8n.cloud/webhook/get-titles?pub=${encodeURIComponent(pub)}`);
        const data = await res.json();
        result.innerHTML = "";
        if (data.error) {
          result.innerHTML = `<span class='error'>❌ ${data.error}</span>`;
        } else {
          for (const [lang, title] of Object.entries(data.titles || {})) {
            const p = document.createElement("p");
            p.innerText = `${lang.toUpperCase()}: ${title}`;
            result.appendChild(p);
          }
        }
      } catch (e) {
        result.innerHTML = `<span class='error'>❌ Failed to fetch titles</span>`;
      }
    }

    // ---- Upload flow ----
    document.getElementById("uploadForm").addEventListener("submit", async function (e) {
      e.preventDefault();
      const fileInput = e.target.querySelector("input[type='file']");
      const statusEl = document.getElementById("uploadStatus");

      if (!fileInput.files.length) {
        statusEl.innerHTML = "❌ No file selected";
        return;
      }

      const file = fileInput.files[0];
      const uniqueSuffix = Date.now().toString(36) + "-" + Math.random().toString(36).substring(2, 8);
      const fileName = `upload-${uniqueSuffix}.xlf`;
      statusEl.innerHTML = "⏳ Generating upload URL...";

      try {
        const presignRes = await fetch("https://ipify.app.n8n.cloud/webhook/presign-upload", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ filename: fileName })
        });

        const { uploadUrl, resultUrl } = await presignRes.json();
        if (!uploadUrl || !resultUrl) throw new Error("No presigned URL returned");

        statusEl.innerHTML = "⏳ Uploading to S3...";
        await fetch(uploadUrl, {
          method: "PUT",
          headers: { "Content-Type": "application/octet-stream" },
          body: file
        });

        statusEl.innerHTML = "⏳ File uploaded. Waiting for processing...";
        const maxAttempts = 200;
        let attempts = 0;
        let result = null;

        while (attempts < maxAttempts) {
          const check = await fetch(resultUrl);
          if (check.ok) {
            result = await check.json();
            break;
          }
          await new Promise(res => setTimeout(res, 5000));
          attempts++;
        }

        if (!result) {
          statusEl.innerHTML = "❌ Timed out waiting for processing.";
        } else {
          statusEl.innerHTML = "✅ File processed!";
          renderXlfSegments(result.segments || []);
        }

      } catch (err) {
        console.error(err);
        statusEl.innerHTML = "❌ Upload or processing failed";
      }
    });

    // ---- Generate XTM Link & embed ----
    async function generateXtmLink() {
      const project = document.getElementById("projectName").value.trim();
      const statusEl = document.getElementById("xtmLinkStatus");
      const summaryNote = document.getElementById("xtmSummaryNote");

      if (!project) {
        statusEl.textContent = "⚠️ Enter a project name";
        return;
      }

      statusEl.textContent = "⏳ Generating XTM link...";
      try {
        const res = await fetch(`https://ipify.app.n8n.cloud/webhook/get-xtm-editor?project=${encodeURIComponent(project)}`, {
          method: "GET",
        });

        if (!res.ok) throw new Error("Webhook error");
        const data = await res.json();
        const url = (data && data.url) ? String(data.url) : "";

        if (!url) throw new Error("No URL returned");

        statusEl.textContent = "✅ Link generated";
        // Set and show iframe with fallback if blocked
        loadIframeWithFallback(url);
        // Expand the section and update summary text
        const details = document.getElementById("xtmSection");
        details.open = true;
        summaryNote.textContent = "Embedded (click to collapse)";
        // Remember last URL/state
        localStorage.setItem("xtm_last_url", url);
        localStorage.setItem("xtm_collapsed", "false");

      } catch (err) {
        console.error(err);
        statusEl.textContent = "❌ Failed to generate XTM link";
      }
    }

    function loadIframeWithFallback(url) {
      const iframe = document.getElementById("xtmWorkbench");
      const fallback = document.getElementById("xtmFallback");
      const openInNewTab = document.getElementById("xtmOpenInNewTab");

      // Reset state
      iframe.style.display = "";
      fallback.style.display = "none";
      iframe.removeAttribute("src"); // force reload
      openInNewTab.href = url;

      let loaded = false;
      iframe.onload = () => { loaded = true; };

      // Set src after onload binding
      iframe.src = url;

      // After 3s, assume blocked if not loaded
      setTimeout(() => {
        if (!loaded) {
          iframe.style.display = "none";
          fallback.style.display = "block";
        }
      }, 3000);
    }

    // ---- Persist collapsible state (default collapsed) ----
    (function initCollapsible() {
      const details = document.getElementById("xtmSection");
      const summaryNote = document.getElementById("xtmSummaryNote");
      const saved = localStorage.getItem("xtm_collapsed");
      const lastUrl = localStorage.getItem("xtm_last_url");

      // Default collapsed; only open if explicitly saved as not collapsed
      if (saved === "false") {
        details.open = true;
      }

      details.addEventListener("toggle", () => {
        const collapsed = !details.open;
        localStorage.setItem("xtm_collapsed", String(collapsed));
        summaryNote.textContent = details.open
          ? (lastUrl ? "Embedded (click to collapse)" : "No link generated yet")
          : "Collapsed";
      });

      if (lastUrl) {
        summaryNote.textContent = details.open ? "Embedded (click to collapse)" : "Collapsed";
      }
    })();

    // ---- Filters & table rendering ----
    function createFilterRow(table) {
      const filterRow = table.insertRow();
      filterRow.className = "filter-row";

      const headers = [
        "", "Segment ID", "Source", "Target", "Similarity",
        "Similarity Notes", "Formatting Issues", "Glossary Issues", "Consistency Check"
      ];

      headers.forEach((header, idx) => {
        const cell = document.createElement("th");
        const select = document.createElement("select");
        select.innerHTML = `<option value="">— Filter —</option>`;

        if (idx === 0) {
          select.innerHTML += `<option value="checked">Checked</option><option value="unchecked">Unchecked</option>`;
        } else if (header === "Similarity") {
          select.innerHTML += `<option value="OK">OK</option><option value="CHECK">CHECK</option>`;
        } else {
          select.innerHTML += `<option value="nonempty">Has content</option><option value="empty">Empty</option>`;
        }

        select.addEventListener("change", () => applyFilters(table));
        cell.appendChild(select);
        filterRow.appendChild(cell);
      });
    }

    function applyFilters(table) {
      const filterRow = table.rows[1];
      const filters = Array.from(filterRow.cells).map(cell => cell.firstChild.value);

      for (let i = 2; i < table.rows.length; i++) {
        const row = table.rows[i];
        let show = true;

        filters.forEach((filter, idx) => {
          if (!filter) return;

          if (idx === 0) {
            const isChecked = row.dataset.checked === "true";
            if (filter === "checked" && !isChecked) show = false;
            if (filter === "unchecked" && isChecked) show = false;
          } else {
            const cellText = row.cells[idx].innerText.trim();
            if (idx === 4) {
              if (filter === "OK" && cellText !== "OK") show = false;
              if (filter === "CHECK" && cellText !== "CHECK") show = false;
            } else {
              if (filter === "nonempty" && !cellText) show = false;
              if (filter === "empty" && cellText) show = false;
            }
          }
        });

        row.style.display = show ? "" : "none";
      }
    }

    function renderXlfSegments(segments) {
      const container = document.createElement("div");
      container.className = "box";
      container.id = "xlfPreview";

      const table = document.createElement("table");
      const header = table.insertRow();
      const headers = [
        "", "Segment ID", "Source", "Target", "Similarity", "Similarity Notes",
        "Formatting Issues", "Glossary Issues", "Consistency Check"
      ];

      headers.forEach(col => {
        const th = document.createElement("th");
        th.innerText = col;
        header.appendChild(th);
      });

      createFilterRow(table);

      segments.forEach(seg => {
        const row = table.insertRow();

        const notes = seg["Notes"] || "";
        const quoted = [...notes.matchAll(/'([^"]+?)'/g)].map(m => m[1]);

        const checkboxCell = row.insertCell();
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.addEventListener("change", () => {
          row.classList.toggle("row-highlighted", checkbox.checked);
          row.dataset.checked = checkbox.checked ? "true" : "false";
        });
        checkboxCell.appendChild(checkbox);
        row.dataset.checked = "false";

        const fields = [
          seg["Segment ID"], seg["Source"], seg["Target"], seg["Similarity"],
          notes, seg["FormattingIssues"] || "", seg["GlossaryIssues"] || "", seg["ConsistencyCheck"] || ""
        ];

        fields.forEach((val, i) => {
          const cell = row.insertCell();
          if ((i === 1 || i === 2) && typeof val === "string") {
            let html = val;
            quoted.forEach(q => {
              const escaped = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const regex = new RegExp(escaped, 'gi');
              html = html.replace(regex, match => `<span class="quoted-term">${match}</span>`);
            });
            cell.innerHTML = html;
          } else {
            cell.innerText = val;
          }

          if (i === 3) {
            if (val === "OK") cell.className = "ok-cell";
            else if (val === "CHECK") cell.className = "check-cell";
          }

          if ([3, 4, 5, 6, 7].includes(i)) {
            cell.style.cursor = "pointer";
            cell.addEventListener("click", () => {
              const active = cell.dataset.active === "true";
              if (!active) {
                cell.style.backgroundColor = "#c8f7c5";
                cell.style.color = "gray";
                cell.style.fontStyle = "italic";
                cell.dataset.active = "true";
              } else {
                cell.style.backgroundColor = "";
                cell.style.color = "";
                cell.style.fontStyle = "";
                cell.dataset.active = "false";
              }
            });
          }

          if (typeof val === "string" && val.trim() !== "" && i > 2 && i !== 3) {
            cell.classList.add("highlight-cell");
          }
        });
      });

      const previewContainer = document.getElementById("xlfPreviewContainer");
      previewContainer.innerHTML = "";
      container.appendChild(table);
      previewContainer.appendChild(container);
      container.scrollIntoView({ behavior: "smooth" });
    }

    // ---- Existing XTM file fetch (unchanged) ----
    async function fetchXlfByProject() {
      const project = document.getElementById("projectName").value.trim();
      const statusEl = document.getElementById("projectFetchStatus");

      if (!project) {
        statusEl.innerText = "⚠️ Enter a project name";
        return;
      }

      statusEl.innerText = "⏳ Fetching file...";

      try {
        const response = await fetch(`https://ipify.app.n8n.cloud/webhook/get-xlf-file?project=${encodeURIComponent(project)}`);
        if (!response.ok) throw new Error("File not found or server error");

        const blob = await response.blob();
        const file = new File([blob], `${project}.xlf`, { type: 'application/x-xliff+xml' });

        const uniqueSuffix = Date.now().toString(36) + "-" + Math.random().toString(36).substring(2, 8);
        const fileName = `upload-${uniqueSuffix}.xlf`;
        statusEl.innerText = "⏳ Generating upload URL...";

        const presignRes = await fetch("https://ipify.app.n8n.cloud/webhook/presign-upload", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ filename: fileName })
        });

        const { uploadUrl, resultUrl } = await presignRes.json();
        if (!uploadUrl || !resultUrl) throw new Error("No presigned URL returned");

        statusEl.innerText = "⏳ Uploading file...";
        await fetch(uploadUrl, {
          method: "PUT",
          headers: { "Content-Type": "application/octet-stream" },
          body: file
        });

        statusEl.innerText = "⏳ Processing file...";
        const maxAttempts = 200;
        let attempts = 0;
        let result = null;

        while (attempts < maxAttempts) {
          const check = await fetch(resultUrl);
          if (check.ok) {
            result = await check.json();
            break;
          }
          await new Promise(res => setTimeout(res, 5000));
          attempts++;
        }

        if (!result) {
          statusEl.innerText = "❌ Timed out waiting for processing.";
        } else {
          statusEl.innerText = "✅ File processed!";
          renderXlfSegments(result.segments || []);
        }

      } catch (err) {
        console.error(err);
        statusEl.innerText = "❌ Failed to fetch or process file";
      }
    }
  </script>
</body>
</html>
