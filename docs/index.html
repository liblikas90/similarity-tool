<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EP Patent Tool</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .input-group { margin-bottom: 20px; }
    .container { display: flex; gap: 30px; }
    .left, .right { flex: 1; display: flex; flex-direction: column; gap: 20px; }
    .box { padding: 10px; border: 1px solid #ccc; border-radius: 8px; background-color: #f9f9f9; }
    .upload-box { max-width: 400px; }
    .upload-box input[type="file"] { display: block; margin-bottom: 10px; }
    .loading { color: orange; }
    .error { color: red; }
    .unavailable { color: gray; font-style: italic; }
    h2 { margin-top: 0; }
    #uploadStatus { display: block; margin-top: 10px; }

    #projectName { width: 100%; box-sizing: border-box; }

    table { width: 100%; border-collapse: collapse; margin-top: 20px; table-layout: fixed; }
    th, td { padding: 6px; border: 1px solid #ccc; word-break: break-word; white-space: normal; vertical-align: top; }
    th { background-color: #eee; }

    /* Segments preview column widths */
    #xlfPreview th:nth-child(1), #xlfPreview td:nth-child(1) { width: 40px; }
    #xlfPreview th:nth-child(2), #xlfPreview td:nth-child(2) { width: 120px; }
    #xlfPreview th:nth-child(3), #xlfPreview td:nth-child(3) { width: 24%; }
    #xlfPreview th:nth-child(4), #xlfPreview td:nth-child(4) { width: 24%; }
    #xlfPreview th:nth-child(5), #xlfPreview td:nth-child(5) { width: 90px; }

    #xlfPreview { margin-top: 40px; max-width: 100%; }
    .ok-cell { background-color: #d4edda; }
    .check-cell { background-color: #ffeeba; }
    .highlight-cell { background-color: #ffe4b2; }
    .row-highlighted { background-color: #ffffcc !important; }
    .quoted-term { color: red; font-weight: bold; }
    .filter-row select { width: 100%; padding: 4px; font-size: 12px; }
    .actions-row { display: flex; gap: 8px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
    .muted { color: #666; font-size: 12px; }

    /* Tabs */
    .tabs { display: flex; gap: 8px; margin-top: 20px; }
    .tab-btn {
      padding: 6px 10px; border: 1px solid #ccc; background: #f3f3f3; cursor: pointer;
      border-radius: 6px 6px 0 0; font-size: 14px;
    }
    .tab-btn.active { background: #fff; border-bottom-color: #fff; }
    .tab-pane { border: 1px solid #ccc; border-top: none; padding: 10px; background: #fff; }
    th.sortable { cursor: pointer; user-select: none; }
  </style>
</head>
<body>
  <h1>EP Patent Tool</h1>

  <div class="input-group">
    <input type="text" id="pubNum" placeholder="e.g., EP1000000" />
    <button onclick="fetchPatentInfo()">Get Title</button>
  </div>

  <div class="container">
    <div class="left">
      <div class="box">
        <h2>Titles</h2>
        <div id="result"></div>
      </div>

      <div style="display: flex; gap: 20px; align-items: flex-start; margin-top: 20px;">
        <div class="box upload-box">
          <h2>Upload .xlf File</h2>
          <form id="uploadForm">
            <input type="file" name="file" accept=".xlf" />
            <button type="submit" style="margin-top: 8px;">Upload</button>
            <span id="uploadStatus"></span>
          </form>
        </div>

        <div class="box upload-box">
          <h2>Get XLF from XTM</h2>
          <input type="text" id="projectName" placeholder="e.g. EP1234567 I01060 (EN-FR)" />
          <div class="actions-row">
            <button onclick="fetchXlfByProject()">Fetch</button>
            <button onclick="generateXtmLink()">Generate XTM Link</button>
            <span id="projectFetchStatus" class="muted"></span>
            <span id="xtmLinkStatus" class="muted"></span>
          </div>
        </div>
      </div>

      <!-- XTM Workbench (collapsible, default collapsed) -->
      <details id="xtmSection" class="box" style="margin-top: 20px;">
        <summary style="cursor: pointer; user-select: none;">
          <strong>XTM Workbench</strong>
          <span id="xtmSummaryNote" class="unavailable" style="margin-left: 8px;">No link generated yet</span>
        </summary>
        <div id="xtmContainer" style="width: 100%; height: 800px; margin-top: 10px;">
          <iframe id="xtmWorkbench" src="" width="100%" height="100%" style="border: none;"></iframe>
        </div>
        <p id="xtmFallback" class="unavailable" style="display: none; margin-top: 8px;">
          ⚠️ Unable to embed the workbench.
          <a id="xtmOpenInNewTab" href="#" target="_blank" rel="noopener">Open XTM Workbench in a new tab</a>
        </p>
      </details>

      <!-- Tabs -->
      <div class="tabs">
        <button class="tab-btn active" data-tab="tab-segments" id="tabBtnSegments">Segments</button>
        <button class="tab-btn" data-tab="tab-consistency" id="tabBtnConsistency">Reference Consistency</button>
      </div>

      <!-- Tab contents -->
      <div id="tab-segments" class="tab-pane" style="display:block;">
        <div id="xlfPreviewContainer" style="margin-top: 20px;"></div>
      </div>

      <div id="tab-consistency" class="tab-pane" style="display:none;">
        <div class="box" id="consistencyBox">
          <h2>Reference Consistency</h2>
          <div id="consistencyContainer"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---- Titles ----
    async function fetchPatentInfo() {
      const pub = document.getElementById("pubNum").value.trim();
      const result = document.getElementById("result");
      result.innerHTML = "<span class='loading'>⏳ Fetching titles...</span>";

      try {
        const res = await fetch(`https://ipify.app.n8n.cloud/webhook/get-titles?pub=${encodeURIComponent(pub)}`);
        const data = await res.json();
        result.innerHTML = "";
        if (data.error) {
          result.innerHTML = `<span class='error'>❌ ${data.error}</span>`;
        } else {
          for (const [lang, title] of Object.entries(data.titles || {})) {
            const p = document.createElement("p");
            p.innerText = `${lang.toUpperCase()}: ${title}`;
            result.appendChild(p);
          }
        }
      } catch {
        result.innerHTML = `<span class='error'>❌ Failed to fetch titles</span>`;
      }
    }

    // ---- Tabs ----
    (function initTabs() {
      const buttons = document.querySelectorAll('.tab-btn');
      const panes = document.querySelectorAll('.tab-pane');
      function showTab(id) {
        buttons.forEach(b => b.classList.toggle('active', b.dataset.tab === id));
        panes.forEach(p => p.style.display = (p.id === id) ? '' : 'none');
      }
      buttons.forEach(btn => btn.addEventListener('click', () => showTab(btn.dataset.tab)));
      // expose for programmatic switching
      window._showTab = showTab;
    })();

    // ---- Upload flow ----
    document.getElementById("uploadForm").addEventListener("submit", async function (e) {
      e.preventDefault();
      const fileInput = e.target.querySelector("input[type='file']");
      const statusEl = document.getElementById("uploadStatus");

      if (!fileInput.files.length) { statusEl.innerHTML = "❌ No file selected"; return; }

      const file = fileInput.files[0];
      const uniqueSuffix = Date.now().toString(36) + "-" + Math.random().toString(36).substring(2, 8);
      const fileName = `upload-${uniqueSuffix}.xlf`;
      statusEl.innerHTML = "⏳ Generating upload URL...";

      try {
        const presignRes = await fetch("https://ipify.app.n8n.cloud/webhook/presign-upload", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ filename: fileName })
        });

        const { uploadUrl, resultUrl } = await presignRes.json();
        if (!uploadUrl || !resultUrl) throw new Error("No presigned URL returned");

        statusEl.innerHTML = "⏳ Uploading to S3...";
        await fetch(uploadUrl, { method: "PUT", headers: { "Content-Type": "application/octet-stream" }, body: file });

        statusEl.innerHTML = "⏳ File uploaded. Waiting for processing...";
        const maxAttempts = 500, delayMs = 5000;
        let attempts = 0, result = null;

        while (attempts < maxAttempts) {
          const check = await fetch(resultUrl);
          if (check.ok) { result = await check.json(); break; }
          await new Promise(res => setTimeout(res, delayMs));
          attempts++;
        }

        if (!result) {
          statusEl.innerHTML = "❌ Timed out waiting for processing.";
        } else {
          statusEl.innerHTML = "✅ File processed!";
          renderXlfSegments(result.segments || []);

          // ✅ Auto-render consistency if similarity included in the response
          if (result.similarity) {
            loadReferenceConsistency(result.similarity);   // renders table
            window._showTab('tab-consistency');            // auto-switch to the tab
          }
        }

      } catch (err) {
        console.error(err);
        statusEl.innerHTML = "❌ Upload or processing failed";
      }
    });

    // ---- XTM Link ----
    async function generateXtmLink() {
      const project = document.getElementById("projectName").value.trim();
      const statusEl = document.getElementById("xtmLinkStatus");
      const summaryNote = document.getElementById("xtmSummaryNote");

      if (!project) { statusEl.textContent = "⚠️ Enter a project name"; return; }

      statusEl.textContent = "⏳ Generating XTM link...";
      try {
        const res = await fetch(`https://ipify.app.n8n.cloud/webhook/get-xtm-editor?project=${encodeURIComponent(project)}`);
        if (!res.ok) throw new Error("Webhook error");
        const data = await res.json();
        const url = (data && data.url) ? String(data.url) : "";
        if (!url) throw new Error("No URL returned");

        statusEl.textContent = "✅ Link generated";
        loadIframeWithFallback(url);
        const details = document.getElementById("xtmSection");
        details.open = true;
        summaryNote.textContent = "Embedded (click to collapse)";
        localStorage.setItem("xtm_last_url", url);
        localStorage.setItem("xtm_collapsed", "false");

      } catch (err) {
        console.error(err);
        statusEl.textContent = "❌ Failed to generate XTM link";
      }
    }

    function loadIframeWithFallback(url) {
      const iframe = document.getElementById("xtmWorkbench");
      const fallback = document.getElementById("xtmFallback");
      const openInNewTab = document.getElementById("xtmOpenInNewTab");

      iframe.style.display = "";
      fallback.style.display = "none";
      iframe.removeAttribute("src");
      openInNewTab.href = url;

      let loaded = false;
      iframe.onload = () => { loaded = true; };
      iframe.src = url;

      setTimeout(() => {
        if (!loaded) { iframe.style.display = "none"; fallback.style.display = "block"; }
      }, 3000);
    }

    // ---- Persist collapsible state ----
    (function initCollapsible() {
      const details = document.getElementById("xtmSection");
      const summaryNote = document.getElementById("xtmSummaryNote");
      const saved = localStorage.getItem("xtm_collapsed");
      const lastUrl = localStorage.getItem("xtm_last_url");
      if (saved === "false") details.open = true;

      details.addEventListener("toggle", () => {
        const collapsed = !details.open;
        localStorage.setItem("xtm_collapsed", String(collapsed));
        summaryNote.textContent = details.open
          ? (lastUrl ? "Embedded (click to collapse)" : "No link generated yet")
          : "Collapsed";
      });

      if (lastUrl) { summaryNote.textContent = details.open ? "Embedded (click to collapse)" : "Collapsed"; }
    })();

    // ---- Segments table (unchanged structure) ----
    function createFilterRow(table) {
      const filterRow = table.insertRow();
      filterRow.className = "filter-row";
      const headers = ["", "Segment ID", "Source", "Target", "Similarity", "Similarity Notes", "Formatting Issues", "Glossary Issues", "Consistency Check"];
      headers.forEach((header, idx) => {
        const cell = document.createElement("th");
        const select = document.createElement("select");
        select.innerHTML = `<option value="">— Filter —</option>`;
        if (idx === 0) {
          select.innerHTML += `<option value="checked">Checked</option><option value="unchecked">Unchecked</option>`;
        } else if (header === "Similarity") {
          select.innerHTML += `<option value="OK">OK</option><option value="CHECK">CHECK</option>`;
        } else {
          select.innerHTML += `<option value="nonempty">Has content</option><option value="empty">Empty</option>`;
        }
        select.addEventListener("change", () => applyFilters(table));
        cell.appendChild(select);
        filterRow.appendChild(cell);
      });
    }

    function applyFilters(table) {
      const filterRow = table.rows[1];
      const filters = Array.from(filterRow.cells).map(cell => cell.firstChild.value);
      for (let i = 2; i < table.rows.length; i++) {
        const row = table.rows[i];
        let show = true;
        filters.forEach((filter, idx) => {
          if (!filter) return;
          if (idx === 0) {
            const isChecked = row.dataset.checked === "true";
            if (filter === "checked" && !isChecked) show = false;
            if (filter === "unchecked" && isChecked) show = false;
          } else {
            const cellText = row.cells[idx].innerText.trim();
            if (idx === 4) {
              if (filter === "OK" && cellText !== "OK") show = false;
              if (filter === "CHECK" && cellText !== "CHECK") show = false;
            } else {
              if (filter === "nonempty" && !cellText) show = false;
              if (filter === "empty" && cellText) show = false;
            }
          }
        });
        row.style.display = show ? "" : "none";
      }
    }

    function renderXlfSegments(segments) {
      const container = document.createElement("div");
      container.className = "box";
      container.id = "xlfPreview";

      const table = document.createElement("table");
      const header = table.insertRow();
      const headers = ["", "Segment ID", "Source", "Target", "Similarity", "Similarity Notes", "Formatting Issues", "Glossary Issues", "Consistency Check"];
      headers.forEach(col => { const th = document.createElement("th"); th.innerText = col; header.appendChild(th); });

      createFilterRow(table);

      segments.forEach(seg => {
        const row = table.insertRow();
        const notes = seg["Notes"] || "";
        const quoted = [...notes.matchAll(/'([^"]+?)'/g)].map(m => m[1]);

        const checkboxCell = row.insertCell();
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.addEventListener("change", () => {
          row.classList.toggle("row-highlighted", checkbox.checked);
          row.dataset.checked = checkbox.checked ? "true" : "false";
        });
        checkboxCell.appendChild(checkbox);
        row.dataset.checked = "false";

        const fields = [
          seg["Segment ID"], seg["Source"], seg["Target"], seg["Similarity"],
          notes, seg["FormattingIssues"] || "", seg["GlossaryIssues"] || "", seg["ConsistencyCheck"] || ""
        ];

        fields.forEach((val, i) => {
          const cell = row.insertCell();
          if ((i === 1 || i === 2) && typeof val === "string") {
            let html = val;
            quoted.forEach(q => {
              const escaped = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const regex = new RegExp(escaped, 'gi');
              html = html.replace(regex, match => `<span class="quoted-term">${match}</span>`);
            });
            cell.innerHTML = html;
          } else {
            cell.innerText = val;
          }

          if (i === 3) {
            if (val === "OK") cell.className = "ok-cell";
            else if (val === "CHECK") cell.className = "check-cell";
          }

          if ([3,4,5,6,7].includes(i)) {
            cell.style.cursor = "pointer";
            cell.addEventListener("click", () => {
              const active = cell.dataset.active === "true";
              if (!active) {
                cell.style.backgroundColor = "#c8f7c5";
                cell.style.color = "gray";
                cell.style.fontStyle = "italic";
                cell.dataset.active = "true";
              } else {
                cell.style.backgroundColor = "";
                cell.style.color = "";
                cell.style.fontStyle = "";
                cell.dataset.active = "false";
              }
            });
          }

          if (typeof val === "string" && val.trim() !== "" && i > 2 && i !== 3) {
            cell.classList.add("highlight-cell");
          }
        });
      });

      const previewContainer = document.getElementById("xlfPreviewContainer");
      previewContainer.innerHTML = "";
      container.appendChild(table);
      previewContainer.appendChild(container);
      container.scrollIntoView({ behavior: "smooth" });
    }

    // ---- Reference Consistency (auto-switch + badge) ----
    function renderReferenceConsistency(bySegment) {
      const container = document.getElementById('consistencyContainer');
      const tabBtn = document.getElementById('tabBtnConsistency');
      container.innerHTML = '';

      // Flatten rows
      const rows = [];
      Object.keys(bySegment || {}).forEach(segId => {
        const list = bySegment[segId] || [];
        list.forEach(entry => {
          rows.push({
            segment: Number(segId),
            source_term: entry.source_term ?? '',
            source_key: entry.source_key ?? '',
            target_term: entry.target_term ?? '',
            target_key: entry.target_key ?? ''
          });
        });
      });

      // Update tab badge
      tabBtn.textContent = `Reference Consistency${rows.length ? ` (${rows.length})` : ''}`;

      if (!rows.length) {
        container.innerHTML = `<p class="muted">No reference candidates found.</p>`;
        return;
      }

      const numPart = (key) => {
        if (!key) return NaN;
        const m = String(key).match(/#(\d+)$/);
        return m ? parseInt(m[1], 10) : NaN;
      };

      rows.forEach(r => {
        r.source_key_num = numPart(r.source_key);
        r.target_key_num = numPart(r.target_key);
      });

      const table = document.createElement('table');
      table.id = 'consistencyTable';
      table.style.width = '100%';
      table.style.borderCollapse = 'collapse';

      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      const headers = [
        { key: 'segment', label: 'Segment' },
        { key: 'source_term', label: 'Source term' },
        { key: 'source_key_num', label: 'Source key (num)' },
        { key: 'target_term', label: 'Target term' },
        { key: 'target_key_num', label: 'Target key (num)' },
      ];
      headers.forEach(h => {
        const th = document.createElement('th');
        th.className = 'sortable';
        th.dataset.col = h.key;
        th.textContent = h.label;
        trh.appendChild(th);
      });
      thead.appendChild(trh);

      const tbody = document.createElement('tbody');
      table.appendChild(thead);
      table.appendChild(tbody);

      function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

      function draw(data) {
        tbody.innerHTML = '';
        data.forEach(r => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${r.segment}</td>
            <td>${escapeHtml(r.source_term)}</td>
            <td>${isNaN(r.source_key_num) ? '' : r.source_key_num}</td>
            <td>${escapeHtml(r.target_term)}</td>
            <td>${isNaN(r.target_key_num) ? '' : r.target_key_num}</td>
          `;
          Array.from(tr.children).forEach(td => { td.style.border = '1px solid #ccc'; td.style.padding = '6px'; });
          tbody.appendChild(tr);
        });
      }

      let sortState = { col: 'segment', dir: 'asc' };
      function sortRows(col, dir) {
        const copy = rows.slice();
        copy.sort((a, b) => {
          const A = a[col], B = b[col];
          const bothNum = typeof A === 'number' && !isNaN(A) && typeof B === 'number' && !isNaN(B);
          let cmp = bothNum ? (A - B) : String(A ?? '').localeCompare(String(B ?? ''), undefined, { sensitivity: 'base' });
          return dir === 'asc' ? cmp : -cmp;
        });
        draw(copy);
      }

      thead.querySelectorAll('th.sortable').forEach(th => {
        th.addEventListener('click', () => {
          const col = th.dataset.col;
          sortState.dir = (sortState.col === col && sortState.dir === 'asc') ? 'desc' : 'asc';
          sortState.col = col;
          sortRows(sortState.col, sortState.dir);
          // arrows
          thead.querySelectorAll('th').forEach(h => h.textContent = h.textContent.replace(/[\u25B2\u25BC]\s*$/,'').trim());
          th.textContent = th.textContent.replace(/[\u25B2\u25BC]\s*$/,'').trim() + (sortState.dir === 'asc' ? ' ▲' : ' ▼');
        });
      });

      container.appendChild(table);
      sortRows(sortState.col, sortState.dir);
    }

    // Accepts the exact payload you showed (array with one object)
    function loadReferenceConsistency(similarityPayload) {
      const root = Array.isArray(similarityPayload) ? similarityPayload[0] : similarityPayload;
      const bySeg = root?.sourceandtargetcandidatekeys?.by_segment || {};
      renderReferenceConsistency(bySeg);
    }

    // Expose in case similarity arrives later via a different webhook:
    // call window.setSimilarity(payload) and it will render + switch tab.
    window.setSimilarity = function(similarityPayload) {
      loadReferenceConsistency(similarityPayload);
      window._showTab('tab-consistency');
    };

    // ---- Existing XTM file fetch (unchanged except: auto-consistency render if present) ----
    async function fetchXlfByProject() {
      const project = document.getElementById("projectName").value.trim();
      const statusEl = document.getElementById("projectFetchStatus");
      if (!project) { statusEl.innerText = "⚠️ Enter a project name"; return; }

      statusEl.innerText = "⏳ Fetching file...";
      try {
        const response = await fetch(`https://ipify.app.n8n.cloud/webhook/get-xlf-file?project=${encodeURIComponent(project)}`);
        if (!response.ok) throw new Error("File not found or server error");
        const blob = await response.blob();
        const file = new File([blob], `${project}.xlf`, { type: 'application/x-xliff+xml' });

        const uniqueSuffix = Date.now().toString(36) + "-" + Math.random().toString(36).substring(2, 8);
        const fileName = `upload-${uniqueSuffix}.xlf`;
        statusEl.innerText = "⏳ Generating upload URL...";

        const presignRes = await fetch("https://ipify.app.n8n.cloud/webhook/presign-upload", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ filename: fileName })
        });

        const { uploadUrl, resultUrl } = await presignRes.json();
        if (!uploadUrl || !resultUrl) throw new Error("No presigned URL returned");

        statusEl.innerText = "⏳ Uploading file...";
        await fetch(uploadUrl, { method: "PUT", headers: { "Content-Type": "application/octet-stream" }, body: file });

        statusEl.innerText = "⏳ Processing file...";
        const maxAttempts = 500, delayMs = 5000;
        let attempts = 0, result = null;

        while (attempts < maxAttempts) {
          const check = await fetch(resultUrl);
          if (check.ok) { result = await check.json(); break; }
          await new Promise(res => setTimeout(res, delayMs));
          attempts++;
        }

        if (!result) {
          statusEl.innerText = "❌ Timed out waiting for processing.";
        } else {
          statusEl.innerText = "✅ File processed!";
          renderXlfSegments(result.segments || []);
          if (result.similarity) { loadReferenceConsistency(result.similarity); window._showTab('tab-consistency'); }
        }

      } catch (err) {
        console.error(err);
        statusEl.innerText = "❌ Failed to fetch or process file";
      }
    }
  </script>
</body>
</html>
